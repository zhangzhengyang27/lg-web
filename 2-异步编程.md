# 异步编程

## 内容概要

1. 同步模式和异步模式(主要是dom操作)
2. 事件循环与消息队列
3. 异步编程的几种方式
4. Promise异步方案、宏任务/微任务队列
5. Generator异步方案、Async/Await语法糖

## 同步模式

```js
// 排队执行
console.log('global begin')
function bar () {
	console.log('bar task') 
}
function foo () {
	console.log('foo task')
	bar()
}
foo()
console.log('global end')
```

### 分析调用顺序

1. 分为右边的call stack的调用栈；左下角的console控制台

   ![同步模式调用顺序1](https://interview-aliyun.oss-cn-beijing.aliyuncs.com/img/%E5%90%8C%E6%AD%A5%E6%A8%A1%E5%BC%8F%E8%B0%83%E7%94%A8%E9%A1%BA%E5%BA%8F1.png)

2. 在call stack栈中压入call stack的调用栈的一个匿名函数中，可以理解为把全部的代码放到了一个匿名函数中去执行。

3. 然后逐行执行代码

4. 将console.log('global begin')压入调用栈，在console中输出global begin,然后再调用栈中弹出console.log('global begin')的函数

5. 代码执行到foo()这行，将foo()压入调用栈，进入foo()函数内部，将console.log('foo task')压入栈

   ![同步模式顺序调用2](https://interview-aliyun.oss-cn-beijing.aliyuncs.com/img/%E5%90%8C%E6%AD%A5%E6%A8%A1%E5%BC%8F%E9%A1%BA%E5%BA%8F%E8%B0%83%E7%94%A82.png)

6. 在console中输出foo task,然后再调用栈中弹出console.log('foo task')的函数，现在剩下foo()、anonymous两个函数

7. 调用bar()函数，将bar()压入调用栈，进入bar()函数内部，将console.log('bar task') 压入调用栈，在console中输出bar task,然后再调用栈中弹出console.log('bar task')的函数，继续弹出bar()函数

8. 弹出foo()、压入console.log('global end')，执行完，弹出anonymous函数

## 异步模式

不会去等待这个任务的结束才可以下一个任务,开启过后就立即往后执行下一个任务，后续逻辑一般会通过回调函数的方式定义

单线程的js语法就无法同时处理大量的耗时任务

```js
console.log('global begin')

setTimeout(function timer1() {
    console.log('timer1 invoke')
}, 1800)

setTimeout(function timer2() {
    console.log('timer2 invoke')
    setTimeout(function inner() {
        console.log('inner invoke')
    }, 1000)
}, 1000)

console.log('global end')

// global begin
// global end
// timer2 invoke
// timer1 invoke
// inner invoke
```

![异步模式调用1](https://interview-aliyun.oss-cn-beijing.aliyuncs.com/img/%E5%BC%82%E6%AD%A5%E6%A8%A1%E5%BC%8F%E8%B0%83%E7%94%A81.png)

Queue:消息队列

Event loop:负责监听调用栈和信息队列，一旦调用栈结束，就会从消息队列取出第一个回调函数，压入调用栈执行

1. 加载整体的代码，在调用栈中压入一个anonymons匿名函数

2. 将console.log('global begin')压入栈，执行，弹出栈

3. 将setTimeout(timer1)压入调用栈，在内部API中开启一个倒计时的计时器，单独工作，不受js线程的影响；开启倒计时过后，就将setTimeout(timer1)弹出栈

   ![异步模式调用2](https://interview-aliyun.oss-cn-beijing.aliyuncs.com/img/%E5%BC%82%E6%AD%A5%E6%A8%A1%E5%BC%8F%E8%B0%83%E7%94%A82.png)

4. 将setTimeout(timer2)压入调用栈，在内部API中开启一个倒计时的计时器，单独工作，不受js线程的影响；开启倒计时过后，就将setTimeout(timer2)弹出栈

5. 将console.log('global end')压入栈，执行，弹出栈，执行完之后将调用栈清空

6. webApis 中两个定时器,timer2先执行完，将timer2放到Queue中第一位，timer1放到第二位

   ![异步模式调用3](https://interview-aliyun.oss-cn-beijing.aliyuncs.com/img/%E5%BC%82%E6%AD%A5%E6%A8%A1%E5%BC%8F%E8%B0%83%E7%94%A83.png)

7. Event loop会监听到，就会将timer2()放到调用栈中，将console.log('inner')压入栈中，出栈

8. 将setTimeout(inner)压入调用栈，在内部API中开启一个倒计时的计时器，单独工作，不受js线程的影响；开启倒计时过后，就将setTimeout(inner)弹出栈

9. Event loop会监听到，就会将timer1()放到调用栈中，将console.log('timer1 invoke')压入栈中，出栈

10. 后续同理........

就是先执行完调用栈，然后通过事件循环取出事件压入调用栈中执行

JS是单线程而浏览器不是单线程的

![lg异步线程](https://interview-aliyun.oss-cn-beijing.aliyuncs.com/img/lg%E5%BC%82%E6%AD%A5%E7%BA%BF%E7%A8%8B.png)

## 回调函数

所有异步编程方案的根基

由调用者定义，交给执行者执行的函数

## Promise

一种更优的异步编程同意方案

![lg-promise](https://interview-aliyun.oss-cn-beijing.aliyuncs.com/img/lg-promise.png)

### 基本用法

```js
// Promise 基本示例

const promise = new Promise(function (resolve, reject) {
    // 这里用于“兑现”承诺

    resolve(100) // 承诺达成

    reject(new Error('promise rejected')) // 承诺失败
})

// 第一个是OnFulfiled 的回调函数
promise.then(function (value) {
    // 即便没有异步操作，then 方法中传入的回调仍然会被放入队列，等待下一轮执行
    console.log('resolved', value)
}, function (error) {
    console.log('rejected', error)
})

console.log('end')
// end
// resolved 100
```

使用promise封装ajax

```js
// Promise 方式的 AJAX

function ajax(url) {
    return new Promise(function (resolve, reject) {
        var xhr = new XMLHttpRequest()
        xhr.open('GET', url)
        xhr.responseType = 'json'
        xhr.onload = function () {
            if (this.status === 200) {
                resolve(this.response)
            } else {
                reject(new Error(this.statusText))
            }
        }
        xhr.send()
    })
}

ajax('/api/foo.json').then(function (res) {
    console.log(res)
}, function (error) {
    console.log(error)
})
```

### 常见误区

```js
// Promise 常见误区

function ajax (url) {
  return new Promise(function (resolve, reject) {
    var xhr = new XMLHttpRequest()
    xhr.open('GET', url)
    xhr.responseType = 'json'
    xhr.onload = function () {
      if (this.status === 200) {
        resolve(this.response)
      } else {
        reject(new Error(this.statusText))
      }
    }
    xhr.send()
  })
}

// 嵌套使用 Promise 是最常见的误区
// ajax('/api/urls.json').then(function (urls) {
//   ajax(urls.users).then(function (users) {
//     ajax(urls.users).then(function (users) {
//       ajax(urls.users).then(function (users) {
//         ajax(urls.users).then(function (users) {

//         })
//       })
//     })
//   })
// })
```

### 链式调用

- Promise对象的then方法会返回一个全新的Promise对象
- 后面的then方法就是在为上一个then返回的promise注册回调
- 前面then方法中回调函数的返回值会作为后面then方法回调的参数
- 如果回调中国返回的是Promise，那后面then方法的回调会等待它的结束

```js
// Promise 链式调用 then 返货一个全新的promise

function ajax(url) {
    return new Promise(function (resolve, reject) {
        var xhr = new XMLHttpRequest()
        xhr.open('GET', url)
        xhr.responseType = 'json'
        xhr.onload = function () {
            if (this.status === 200) {
                resolve(this.response)
            } else {
                reject(new Error(this.statusText))
            }
        }
        xhr.send()
    })
}

var promise = ajax('/api/users.json')

var promise2 = promise.then(
    function onFulfilled(value) {
        console.log('onFulfilled', value)
    },
    function onRejected(error) {
        console.log('onRejected', error)
    }
)

// then 返货一个全新的promise
console.log(promise2 === promise)  // false

ajax('/api/users.json')
    .then(function (value) {
        console.log(1111)
        return ajax('/api/urls.json')
    }) // => Promise
    .then(function (value) {
        console.log(2222)
        console.log(value)
        return ajax('/api/urls.json')
    }) // => Promise
    .then(function (value) {
        console.log(3333)
        return ajax('/api/urls.json')
    }) // => Promise
    .then(function (value) {
        console.log(4444)
        return 'foo'
    }) // => Promise
    .then(function (value) {
        console.log(5555)
        console.log(value)
    })
```

### 异常处理

```js
// Promise 异常处理

function ajax(url) {
    return new Promise(function (resolve, reject) {
        // foo()  也会被reject 捕获
        // throw new Error()  也会被reject 捕获
        var xhr = new XMLHttpRequest()
        xhr.open('GET', url)
        xhr.responseType = 'json'
        xhr.onload = function () {
            if (this.status === 200) {
                resolve(this.response)
            } else {
                reject(new Error(this.statusText))
            }
        }
        xhr.send()
    })
}

ajax('/api/users11.json')
    .then(function onFulfilled(value) {
        console.log('onFulfilled', value)
    }, function onRejected(error) {
        console.log('onRejected', error)
    })

// 使用 catch 注册失败回调是更常见的

ajax('/api/users11.json')
    .then(function onFulfilled(value) {
        console.log('onFulfilled', value)
    })
    .catch(function onRejected(error) {
        console.log('onRejected', error)
    })

// then(onRejected) 实际上就相当于 then(undefined, onRejected)

ajax('/api/users11.json')
    .then(function onFulfilled(value) {
        console.log('onFulfilled', value)
    })
    .then(undefined, function onRejected(error) {
        console.log('onRejected', error)
    })

// 同时注册的 onRejected 只是给当前 Promise 对象注册的失败回调
// 它只能捕获到当前 Promise 对象的异常

ajax('/api/users.json')
  .then(function onFulfilled (value) {
    console.log('onFulfilled', value)
    // 这个异常不会被捕获
    return ajax('/error-url')
  }, function onRejected (error) {
    // 不会捕获 ajax('/error-url')
    console.log('onRejected', error)
  })

// 因为 Promise 链条上的任何一个异常都会被一直向后传递，直至被捕获
// 分开注册的 onRejected 相当于给整个 Promise 链条注册失败回调

ajax('/api/users.json')
    .then(function onFulfilled(value) {
        console.log('onFulfilled', value)
        return ajax('/error-url')
    }) // => Promise {}
    .catch(function onRejected(error) {
        // 可以捕获 ajax('/error-url')
        console.log('onRejected', error)
    })

// 全局捕获 Promise 异常，类似于 window.onerror
window.addEventListener('unhandledrejection', event => {
    const {reason, promise} = event

    console.log(reason, promise)
    // reason => Promise 失败原因，一般是一个错误对象
    // promise => 出现异常的 Promise 对象

    event.preventDefault()
}, false)

// Node.js 中使用以下方式
process.on('unhandledRejection', (reason, promise) => {
  console.log(reason, promise)
  // reason => Promise 失败原因，一般是一个错误对象
  // promise => 出现异常的 Promise 对象
})
```

### 静态方法

```js
// 常用 Promise 静态方法

function ajax (url) {
  return new Promise(function (resolve, reject) {
    var xhr = new XMLHttpRequest()
    xhr.open('GET', url)
    xhr.responseType = 'json'
    xhr.onload = function () {
      if (this.status === 200) {
        resolve(this.response)
      } else {
        reject(new Error(this.statusText))
      }
    }
    xhr.send()
  })
}

// 快速将一个值转换为promise对象
Promise.resolve('foo')
  .then(function (value) {
    console.log(value)
  })
// 等价于new Promise方式创建
new Promise(function (resolve, reject) {
  resolve('foo')
})


// 如果传入的是一个 Promise 对象，Promise.resolve 方法原样返回
var promise = ajax('/api/users.json')
var promise2 = Promise.resolve(promise)
// true
console.log(promise === promise2)

// 如果传入的是带有一个跟 Promise 一样的 then 方法的对象，
// Promise.resolve 会将这个对象作为 Promise 执行
Promise.resolve({
  then: function (onFulfilled, onRejected) {
    onFulfilled('foo')
  }
})
.then(function (value) {
  console.log(value)
})

// Promise.reject 传入任何值，都会作为这个 Promise 失败的理由

Promise.reject(new Error('rejected'))
  .catch(function (error) {
    console.log(error)
  })

Promise.reject('anything')
  .catch(function (error) {
    console.log(error)
  })
```

### 并行执行

```js
// Promise 并行执行 all

function ajax (url) {
  return new Promise(function (resolve, reject) {
    var xhr = new XMLHttpRequest()
    xhr.open('GET', url)
    xhr.responseType = 'json'
    xhr.onload = function () {
      if (this.status === 200) {
        resolve(this.response)
      } else {
        reject(new Error(this.statusText))
      }
    }
    xhr.send()
  })
}

ajax('/api/users.json')
ajax('/api/posts.json')

// 只有所有的promise成功结束了，才算是成功的
var promise = Promise.all([
  ajax('/api/users.json'),
  ajax('/api/posts.json')
])

promise.then(function (values) {
  console.log(values)
}).catch(function (error) {
  console.log(error)
})

// 请求多个urls
ajax('/api/urls.json')
  .then(value => {
    const urls = Object.values(value)
    const tasks = urls.map(url => ajax(url))
    return Promise.all(tasks)
  })
  .then(values => {
    console.log(values)
  })


// Promise.race 实现超时控制  只会等待第一个结束的任务

const request = ajax('/api/posts.json')
const timeout = new Promise((resolve, reject) => {
  setTimeout(() => reject(new Error('timeout')), 500)
})

Promise.race([
  request,
  timeout
])
.then(value => {
  console.log(value)
})
.catch(error => {
  console.log(error)
})
```

### 执行时序

```js
// 微任务
console.log('global start')

// setTimeout 的回调是 宏任务，进入回调队列排队
setTimeout(() => {
  console.log('setTimeout')
}, 0)

// Promise 的回调是 微任务，本轮调用末尾直接执行
Promise.resolve()
  .then(() => {
    console.log('promise')
  })
  .then(() => {
    console.log('promise 2')
  })
  .then(() => {
    console.log('promise 3')
  })

console.log('global end')
```

## generator

```js
// 生成器函数回顾

function * foo () {
  console.log('start')

  try {
    const res = yield 'foo'
    console.log(res)
  } catch (e) {
    console.log(e)
  }
}

const generator = foo()

const result = generator.next()
console.log(result)


generator.next('bar')

// generator.throw(new Error('Generator error'))
```

```js
// Generator 配合 Promise 的异步方案

function ajax(url) {
    return new Promise((resolve, reject) => {
        var xhr = new XMLHttpRequest()
        xhr.open('GET', url)
        xhr.responseType = 'json'
        xhr.onload = () => {
            if (xhr.status === 200) {
                resolve(xhr.response)
            } else {
                reject(new Error(xhr.statusText))
            }
        }
        xhr.send()
    })
}

function* main() {
    try {
        const users = yield ajax('/api/users.json')
        console.log(users)

        const posts = yield ajax('/api/posts.json')
        console.log(posts)

        const urls = yield ajax('/api/urls11.json')
        console.log(urls)
    } catch (e) {
        console.log(e)
    }
}

function co(generator) {
    const g = generator()

    function handleResult(result) {
        if (result.done) return // 生成器函数结束
        result.value.then(data => {
            handleResult(g.next(data))
        }, error => {
            g.throw(error)
        })
    }

    handleResult(g.next())
}

co(main)
```

## Async/Await

```js
// Async / Await 语法糖

function ajax (url) {
  return new Promise((resolve, reject) => {
    var xhr = new XMLHttpRequest()
    xhr.open('GET', url)
    xhr.responseType = 'json'
    xhr.onload = () => {
      if (xhr.status === 200) {
        resolve(xhr.response)
      } else {
        reject(new Error(xhr.statusText))
      }
    }
    xhr.send()
  })
}


async function main () {
  try {
    const users = await ajax('/api/users.json')
    console.log(users)

    const posts = await ajax('/api/posts.json')
    console.log(posts)

    const urls = await ajax('/api/urls.json')
    console.log(urls)
  } catch (e) {
    console.log(e)
  }
}

const promise = main()

promise.then(() => {
  console.log('all completed')
})
```

