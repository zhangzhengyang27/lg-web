# JavaScript性能优化

1. 性能优化是不可避免的
2. 哪些性能可以看做是性能优化
3. 无处不在的前端性能优化

## 内容概要

- 内存管理
- 垃圾回收与常见GC算法
- V8引擎的垃圾回收
- Performance工具
- 代码优化实例

## JavaScript内存管理

Memory Management

### 内存为什么需要管理

```js
function fn() {
	arrList = []
	arrList[100000] = 'lg is a coder'
}
fn()
// 内存持续升高
```

### 内存管理介绍

- 内存：由可读写单元组成，表示一片可操作空间
- 管理：人为的去操作一片空间的申请、使用和释放
- 内存管理：开发者主动申请空间、使用空间、释放空间
- 管理流程：申请一使用一释放

JavaScript中的内存管理

1. 申请内存空间
2. 使用内存空间
3. 释放内存空间

```js
// 申请
let obj={}

//使用
obj.name='JOJO'

// 释放
obj=null
```

### JavaScript中的垃圾回收

JavaScript中内存管理是自动的

对象不再被引用时是垃圾

对象不能从跟上访问到时就是垃圾

### JavaScript中的可达对象

可以访问到的对象就是可达对象（引用、作用域链）
可达的标准就是从根出发是否能够被找到
JavaScript 中的根就可以理解为是全局变量对象

### JavaScript中的引用与可达

```js
let obj={name:'xm'}
let ali=obj
obj=null
```

可达对象的图示

```js
function objGroup(obj1, obj2) {
    obj1.next = obj2;
    obj2.prev = obj1;
    return {
        o1: obj1,
        o2: obj2
    }
}

let obj=objGroup({name:'obj2'},{name:'obj2'})
```

<img src="https://interview-aliyun.oss-cn-beijing.aliyuncs.com/img/%E5%8F%AF%E8%BE%BE%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%9B%BE%E7%A4%BA1.png" alt="可达对象的图示1" style="zoom:50%;" />

## GC算法介绍

GC就是垃圾回收机制的简写

GC可以找到内存中的垃圾、并释放和回收空间

### GC里的垃圾是什么

程序中不再需要使用的对象

```js
function func() {
	name = 'lg'
	return `${name} is a coder`
}
func()
// 当函数调用过后，name字段就不在被使用，成为垃圾
```

程序中不能再访问到的对象

```js
function func() {
	const name = 'lg'
	return `${name} is a coder`
}
func()
// 当函数调用过后，const name字段就不能再被访问到
```

### GC算法是什么

- GC是一种机制，垃圾回收器完成具体的工作
- 工作的内容就是查找垃圾释放空间、回收空间
- 算法就是工作时查找和回收所遵循的规则

### 常见的GC算法

- 引用计数
- 标记清除
- 标记整理
- 分代回收

### 引用计数算法

#### 引用计数算法的实现原理

核心思想：设置引用数，判断当前引用数是否为0
引用计数器，引用关系改变时修改引用数字，引用数字为0 时立即回收

```js
const user1={age:11}
const user2={age:11}
const user3={age:11}

const nameList=[user1.age,user2.age,user3.age]

function fn() {
    const num1=1;
    const num2=1;
}
fn()
// 当函数调用过后，const name字段就不能再被访问到,技术引用就为0,会被当做垃圾回收
```

#### 引用计数算法的优缺点

优点：

1. 发现垃圾立即回收
2. 最大限度减少程序暂停，减少程序的卡顿事件

缺点：

1. 无法回收循环引用的对象
2. 时间开销大(引用计数需要维护一个数值的变化，时刻监控对象的引用数值)

### 标记清除算法

#### 标记清除算法的实现原理

核心思想：分标记和清除二个阶段完成
遍历所有对象找标记活动对象
遍历所有对象清除没有标记对象(将第一次的标记抹除)
回收相应的空间

#### 标记清除算法的图示

a1和b1应该是局部作用域，没有被引用

![标记清除算法图示1](https://interview-aliyun.oss-cn-beijing.aliyuncs.com/img/%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95%E5%9B%BE%E7%A4%BA1.png)

#### 标记清除算法的优缺点

可以回收循环引用的对象
容易产生碎片化空间，浪费空
不会立即回收垃圾对象

![标记清除算法的弊端](https://interview-aliyun.oss-cn-beijing.aliyuncs.com/img/%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95%E7%9A%84%E5%BC%8A%E7%AB%AF.png)

### 标记整理算法

#### 标记整理算法的原理

标记整理可以看做是标记清除的增强
标记阶段的操作和标记清除一致
清除阶段会先执行整理，移动对象位置，让地址上产生连续

#### 标记整理算法的图示

<img src="https://interview-aliyun.oss-cn-beijing.aliyuncs.com/img/%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95%E5%9B%BE%E7%A4%BA1.png" alt="标记整理算法图示1" style="zoom: 50%;" />

<img src="https://interview-aliyun.oss-cn-beijing.aliyuncs.com/img/%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95%E5%9B%BE%E7%A4%BA2png.png" alt="标记整理算法图示2png" style="zoom:50%;" />

<img src="https://interview-aliyun.oss-cn-beijing.aliyuncs.com/img/%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95%E5%9B%BE%E7%A4%BA3.png" alt="标记整理算法图示3" style="zoom:50%;" />

#### 标记整理算法的优缺点

减少碎片化空间

不会立即回收垃圾对象

移动对象位置，回收效率慢

## V8

V8是一款主流的 JavaScript执行引擎
V8采用即时编译
V8 内存设限

### V8垃圾回收策略

采用分代回收的思想
内存分为新生代、老生代
针对不同对象采用不同算法

<img src="https://interview-aliyun.oss-cn-beijing.aliyuncs.com/img/V8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5%E5%9B%BE%E7%A4%BA.png" alt="V8垃圾回收策略图示" style="zoom:50%;" />



### V8中常用GC算法

- 分代回收
- 空间复制
- 标记清除
- 标记整理
- 标记增量

### V8如何回收新生代对象

V8内存分配

V8 内存空间一分为二
小空间用于存储新生代对象 (32M|16M）
新生代指的是存活时间较短的对象

![V8内存分配](https://interview-aliyun.oss-cn-beijing.aliyuncs.com/img/V8%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.png)

#### 新生代对象回收实现

回收过程采用复制算法+ 标记整理
新生代内存区分为二个等大小空间，使用空间为 From,空闲空间为 To
活动对象存储于 From 空间，标记整理后将活动对象拷贝至 To，From 与 To 交换空间完成释放(直接将from内存释放，之后to变为from的，from变为to)

#### 回收细节说明

拷贝过程中可能出现晋升
晋升就是将新生代对象移动至老生代

判断标准:

一轮GC 还存活的新生代需要晋升
To 空间的使用率超过25%

### V8如何回收新生代对象

#### 老生代对象说明

老年代对象存放在右侧老生代区域，64位操作系统1.4G，32操作系统700M
老年代对象就是指存活时间较长的对象

#### 老生代对象回收实现

主要采用标记清除、标记整理、增量标记算法
首先使用标记清除完成垃圾空间的回收
当出现晋升的时候，就会采用标记整理进行空间优化，减少碎片化空间
采用增量标记进行效率优化(减少页面卡顿)

### 细节对比

新生代区域垃圾回收使用空间换时间(复制算法)
老生代区域垃圾回收不适合复制算法

### 标记增量如何优化垃圾回收

标记增量就是分段进行标记

![标记增量如何优化垃圾回收](https://interview-aliyun.oss-cn-beijing.aliyuncs.com/img/%E6%A0%87%E8%AE%B0%E5%A2%9E%E9%87%8F%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.png)

### V8垃圾回收总结

V8 是一款主流的 JavaScript执行引擎
V8内存设置上限
V8 采用基于分代回收思想实现垃圾回收
V8 内存分为新生代和老生代
V8 垃圾回收常见的GC 算法

## Performance

GC的目的是为了实现内存空间的良性循环
良性循环的基石是合理使用
时刻关注才能确定是否合理
Performance 提供多种监控方式

### 使用步骤

1. 打开浏览器输入目标网址
2. 进入开发人员工具面板，选择性能
3. 开启录制功能，访问具体界面
4. 执行用户行为，一段时间后停止录制
5. 分析界面中记录的内存信息

### 内存问题的外在表现

页面出现延迟加载或经常性暂停
页面持续性出现糟糕的性能
页面的性能随时间延长越来越差

### 界定内存问题的标准

内存泄露：内存使用持续升高
内存膨胀：在多数设备上都存在性能问题
频繁垃圾回收：通过内存变化图进行分析

### 监控内存的几种方式

- 浏览器任务管理器

- Timeline 时序图记录
- 堆快照查找分离 DOM
- 判断是否存在频繁的垃圾回收

### 浏览器任务管理器监控内存

<img src="https://interview-aliyun.oss-cn-beijing.aliyuncs.com/img/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86%E5%99%A8.png" alt="浏览器任务管理器" style="zoom:50%;" />

### Timeline 时序图记录

![timeline记录内存](https://interview-aliyun.oss-cn-beijing.aliyuncs.com/img/timeline%E8%AE%B0%E5%BD%95%E5%86%85%E5%AD%98.png)

### 堆快照查找分离 DOM

#### 什么事分离DOM

- 界面元素存活在 DOM树上
- 垃圾对象时的 DOM 节点(页面上没有，也没有js代码引用)
- 分离状态的 DOM 节点(页面上没有，有js代码引用，导致内存泄漏)

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>堆快照监控内存</title>
</head>
<body>
<button id="btn">Add</button>
</body>
<script>
    let temple

    function test() {
        var ul=document.createElement('ul')
        for (let i = 0; i < 100000; i++) {
            ul.appendChild(document.createElement('p'))
        }
        temple=ul；
      	// temple=null  解决分离dom的问题
    }
    
    document.getElementById('btn').addEventListener('click', test)
</script>
</html>
```

![堆快照](https://interview-aliyun.oss-cn-beijing.aliyuncs.com/img/%E5%A0%86%E5%BF%AB%E7%85%A7.png)

### 判断是否存在频繁GC

GC 工作时应用程序是停止的
频繁且过长的GC 会导致应用假死
用户使用中感知应用卡顿

#### 确定频繁的垃圾回收

- Timeline中频繁的上升下降
- 任务管理器中数据频繁的增加减少

### Performance总结

#### Performance使用

Performance 使用流程

#### 内存问题的相关分析

Performance 时序图监控内存变化
任务管理器监控内存变化
堆块照查找分离 DOM

## V8引擎工作流程

js代码在执行之前会有一个编译的过程

![V8渲染](https://interview-aliyun.oss-cn-beijing.aliyuncs.com/img/V8%E6%B8%B2%E6%9F%93.png)

Scanner是一个扫描器

```js
const username="alishi"

//转变之后
[
  	{
    		"type": "Keyword",
    		"value": "const"
		},
    {
        "type": "Identifier",
        "value": "username"
    }
    ,
    {
        "type": "Punctuator",
        "value": "="
    }
    ,
    {
        "type": "String",
        "value": "alishi"
    }
]
```

Parser是一个解析器，会把词法分析结果中的tokens转换成抽象的语法树（AST）

![V8Ast](https://interview-aliyun.oss-cn-beijing.aliyuncs.com/img/V8Ast.png)

#### 与解析的优点

- 跳过末被使用的代码
- 不生成 AST，创建无变量引用和声明的 scopes
- 依据规范抛出特定错误
- 解析速度更快

#### 全量解析

- 解析被使用的代码
- 生成 AST
- 构建具体 scopes 信息，变量引用、声明等
- 抛出所有语法错误

![全量解析](https://interview-aliyun.oss-cn-beijing.aliyuncs.com/img/%E5%85%A8%E9%87%8F%E8%A7%A3%E6%9E%90.png)

#### Lgnition是V8提供的一个解释器

#### TurboFan是V8提供的编译器模块





## 代码优化介绍

- JavaScript 中的内存管理自动完成
- 执行引擎会使用不同的GC 算法
- 算法工作的目的是为了实现内存空间良性循环
- Performance 工具监测内存变化
- JavaScript 是单线程机制的解释型语言

### 避免全局变量

全局变量挂载在 window 下
全局变量至少有一个引用计数
全局变量存活更久，但持续占用内存

### 避免全局查找

目标变量不存在于当前作用内，通过作用域链向上查找
减少全局查找降低时间消耗
减少不必要的全局变量定义
全局变量数据局部化

### 避免循环引用

循环引用是指多个对象建存在相互引用

### 采用字面量替换New操作

### setTimeout 替换 setinterval

### 采用事件委托

### 合并循环条件和变量

### 代码为什么需要优化

- WEB 应用日益丰富，用户体验至关重要，前端性能备受关注
- 实现相同结果下，哪种类型 JavaScript 代码具有更高性能
- 高性能的背后是数据快速存取，也是优秀内存管理的体现

### 如何精准测试Js性能

本质上就是采集大量的执行样本进行数学统计和分析
使用基于 Benchmark.js 的 https:/jsperf.com/ 完成

### 使用Jsperf流程

使用 GitHub 账号登录
填写个人信息（非必须）
填写详细的测试用例信息(title、slug)
填写准备代码(DOM操作时经常使用）
填写必要有 setup 与 teardown 代码
填写测试代码片段

### 慎用全局变量

- 全局变量定义在全局执行上下文，是所有作用域链的顶端
- 全局执行上下文一直存在于上下文执行栈，直到程序退出
- 如果某个局部作用域出现了同名变量则会遮蔽或污染全局
- 明确数据作用域的情况下，尽量用局部

### 缓存全局变量

将使用中无法避免的全局变量缓存到局部

### 通过原型新增方法

在原型对象上新增实例对象需要的方法

### 避开闭包陷阱

闭包是一种强大的语法
闭包使用不当很容易出现内存泄露
不要为了闭包而闭包

### 避免属性访问方法使用

#### JavaScript 中的面向对象

JS不需属性的访问方法，所有属性都是外部可见的
使用属性访问方法只会增加一层重定义，没有访问的控制力

### For循环优化

### 采用最优循环方式

### 节点添加优化

节点的添加操作必然会有回流和重绘

### 克隆优化节点操作

### 直接量替换 Object操作