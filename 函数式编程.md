### 函数式编程

## 课程介绍

- 为什么要学习函数编程以及什么事函数式编程
- 函数式编程的特性(纯函数、柯里化、函数组合等)
- 函数式编程的应用场景
- 函数式编程库Lodash

## 为什么要学习函数式编程

函数式编程是非常古老的一个概念，早于第一台计算机额的诞生，[函数编程历史](https://zhuanlan.zhihu.com/p/24648375?refer=marisa)

那我们为什么现在要学习函数式编程

1. 函数式编程是随着React的流行受到越来越多的关注
2. Vue3也开始拥抱函数式编程
3. 函数式编程可以抛弃this
4. 打包过程可以更好地tree shaking过滤无用的代码
5. 方便测试、方便并行处理
6. 有更多库可以帮助我们进行函数式开发:lodash、underscore、ramda

## 什么是函数式编程

函数式编程程(Functional Programming, FP)，FP 是编程范式之一，我们常听说的编程范式还有面向过程编程、面向对象编程。

- 面向对象编程的思维方式：把现实世界中的事物抽象成程序世界中的类和对象，通过封装、继承和多态来演示事物事件的联系
- 函数式编程的思维方式：把现实世界的事物和事物之间的**联系**抽象到程序世界（对运算过程进行抽象）

程序的本质：根据输入通过某种运算获得相应的输出，程序开发过程中会涉及很多有输入和输出的函数

函数式编程中的函数指的不是程序中的函数(方法)，而是数学中的函数即映射关系，例如：y= sin(x)，x和y的关系

相同的输入始终要得到相同的输出(纯函数)

函数式编程用来描述数据(函数)之间的映射

```js
// 非函数式 
let num1 = 2 
let num2 = 3 
let sum = num1 + num2 
console.log(sum) 

// 函数式 
function add (n1, n2) { 
		return n1 + n2 
}
let sum = add(2, 3) 
console.log(sum)
```

## 前置知识

1. 函数式一等公民
2. 高阶函数
3. 函数作为返回值

### 函数是一等公民

[MDN First-class Function](https://developer.mozilla.org/zh-CN/docs/Glossary/First-class_Function)

当一门编程语言的函数可以被当作变量一样用时，则称这门语言拥有**头等函数**。例如，在这门语言中，函数可以被当作参数传递给其他函数，可以作为另一个函数的返回值，还可以被赋值给一个变量。

#### 把函数赋值给变量

```js
const foo = function() {
   console.log("foobar");
}
// 用变量来调用它
foo();
```

>**即使你的函数有自己的函数名称，**你仍然可以用这个变量名去调用它。给函数命名只会方便你调试，但不会影响我们调用它。

#### 传递一个函数作为参数

```js
function sayHello() {
   return "Hello, ";
}
function greeting(helloMessage, name) {
  console.log(helloMessage() + name);
}
// 传递 `sayHello` 作为 `greeting` 函数的参数
greeting(sayHello, "JavaScript!"); // Hello, JavaScript!
```

>**回调函数：**我们把一个函数作为参数传递给另外一个函数，那么我们就称这个函数为回调函数。`sayHello()` 函数就是一个回调函数。

#### 返回一个函数

```js
function sayHello() {
   return function() {
      console.log("Hello!");
   }
}
```

>**高阶函数（Higher-Order Function）：**一个返回另外一个函数的函数被称为高阶函数。

我们再来看看上面的例子：假如我们需要调用 `sayHello` 这个函数，然后让它返回一个**匿名函数**，我们有两种方法：

用一个变量

```js
function sayHello() {
   return function() {
      console.log("Hello!");
   }
}
```

>你要用另外一个变量来调用它。如果你直接用 `sayHello` 来调用这个函数，它会返回这个函数自身，而不会调用它里面被返回的函数。

使用双括号

```js
function sayHello() {
   return function() {
      console.log("Hello!");
   }
}
sayHello()();
```

### 高阶函数

#### 什么是高阶函数

1. 可以把函数作为一个参数传递给另一个函数
2. 可以把函数作为另一个函数的返回结果

```js
// forEach
function forEach(array, fn) {
    for (let i = 0; i < array.length; i++) {
        fn(array[i])
    }
}
// 测试
let arr = [1, 3, 4, 7, 8]

forEach(arr, function (item) {
  console.log(item)
})

// filter
function filter(array, fn) {
    let results = []
    for (let i = 0; i < array.length; i++) {
        if (fn(array[i])) {
            results.push(array[i])
        }
    }
    return results
}
// 测试
let arr = [1, 3, 4, 7, 8]
let r = filter(arr, function (item) {
  return item % 2 === 0
})

console.log(r)
```

```js
function makeFn() {
    let msg = 'Hello function'
    return function () {
        console.log(msg)
    }
}

const fn = makeFn()
fn()
// 或者
makeFn()()
```

#### 高阶函数的意义

1. 抽象可以帮我们屏蔽细节，只需要关注与我们的目标
2. 高阶函数式用来抽象通用的问题

```js
// 面向过程的方式
let array = [1, 2, 3, 4] 
for (let i = 0; i < array.length; i++) { 
  console.log(array[i])
}

// 高阶高阶函数 
let array = [1, 2, 3, 4]
forEach(array, item => {
    console.log(item)
})
let r = filter(array, item => {
    return item % 2 === 0
})
```

#### 常用的高阶函数

1. forEach 
2. map 
3. fifilter 
4. every 
5. some 
6. fifind/fifindIndex 
7. reduce 
8. sort

```js
// 模拟map every some
const map = (array, fn) => {
    let results = []
    for (const value of array) {
        results.push(fn(value))
    }
    return results
}
// 测试
let arr = [1, 2, 3, 4]
arr = map(arr, v => v * v)
console.log(arr)

const every = (array, fn) => {
    let result = true
    for (const value of array) {
        result = fn(value)
        if (!result) {
            break
        }
    }
    return result
}
// 测试
let arr = [9, 12, 14]
let r = every(arr, v => v > 10)
console.log(r)

const some = (array, fn) => {
    let result = false
    for (const value of array) {
        result = fn(value)
        if (result) {
            break
        }
    }
    return result
}
// 测试
let arr = [1, 3, 5, 9]
let r = some(arr, v => v % 2 === 0)
console.log(r)
```

### 闭包

#### 什么是闭包

函数和其周围的状态(词法环境)的引用捆绑在一起形成闭包

​	       可以在另一个作用域中调用一个函数的内部函数并访问到该函数的作用域中的成员

```js
// 函数作为返回值 
function makeFn() {
    let msg = 'Hello function'
    return function () {
        console.log(msg)
    }
}

const fn = makeFn()
fn()


function once(fn) {
    let done = false
    return function () {
        if (!done) {
            done = true
            return fn.apply(this, arguments)
        }
    }
}
let pay = once(function (money) { 
  	conconsole.log(`支付：${money} RMB`) 
})
// 只会调用一次
pay(5)
pay(5)
```

#### 闭包的本质

函数在执行的时候会放到一个执行栈上当函数执行完毕之后会从执行栈上移除，**但是堆上的作用域成员因为被外部引用不能释放**，因此内部函数依然可以访问外部函数的成员

#### 闭包案例

```js
// 生成计算数字的多少次幂的函数
function makePower(power) {
    return function (x) {
        return Math.pow(x, power)
    }
}

let power2 = makePower(2)
let power3 = makePower(3)
console.log(power2(4))
console.log(power3(4))
```

```js
// 计算工资的生成
function makeSalary(x) {
    return function (y) {
        return x + y
    }
}

let salaryLevel1 = makeSalary(1500)
let salaryLevel2 = makeSalary(2500)
console.log(salaryLevel1(2000))
console.log(salaryLevel1(3000))
```

## 纯函数

### 什么是纯函数

相同的输入永远会得到相同的输出，而且没有任何可观察的副作用

纯函数就类似数学中的函数(用来描述输入和输出之间的关系)，y=f(x)

1. lodash 是一个纯函数的功能库，提供了对数组、数字、对象、字符串、函数等操作的一些方法
2. 数组的 slice 和 splice 分别是：纯函数和不纯的函数

​		slice 返回数组中的指定部分，不会改变原数组

​		splice 对数组进行操作返回该数组，会改变原数组

```js
let numbers = [1, 2, 3, 4, 5] 
// 纯函数 
numbers.slice(0, 3) 
// => [1, 2, 3] 
numbers.slice(0, 3) 
// => [1, 2, 3] 
numbers.slice(0, 3) 
// => [1, 2, 3] 

// 不纯的函数 
numbers.splice(0, 3) 
// => [1, 2, 3] 
numbers.splice(0, 3) 
// => [4, 5] 
numbers.splice(0, 3) 
// => []

// 纯函数
function getSum (n1, n2) {
  return n1 + n2
}
console.log(getSum(1, 2))
console.log(getSum(1, 2))
console.log(getSum(1, 2))
```

```js
// 演示 lodash
// first / last / toUpper / reverse / each / includes / find / findIndex
const _ = require('lodash')

const array = ['jack', 'tom', 'lucy', 'kate']

console.log(_.first(array))
console.log(_.last(array))

console.log(_.toUpper(_.first(array)))

console.log(_.reverse(array))

const r = _.each(array, (item, index) => {
  console.log(item, index)
})

console.log(r)
```

函数式编程不会保留计算中间的结果，所以变量是不可变的（无状态的）

我们可以把一个函数的执行结果交给另一个函数去处理

### 纯函数的好处

可缓存：因为纯函数对相同的输入始终有相同的结果，所以可以把纯函数的结果缓存

```js
const _ = require('lodash') 
function getArea (r) { 
  return Math.PI * r * r 
}
let getAreaWithMemory = _.memoize(getArea) 
console.log(getAreaWithMemory(4))
```

可以模拟menoize函数

```js
function memoize(f) {
    let cache = {}
    return function () {
        // arguments是一个伪数组
        let arg_str = JSON.stringify(arguments)
        // 没有缓存则调用f函数，传入arguments
        cache[arg_str] = cache[arg_str] || f.apply(f, arguments)
        return cache[arg_str]
    }
}
```

可测试：纯函数让测试更方便(因为纯函数是有输入输出的)

并行处理：

1. 在多线程环境下并行操作共享的内存数据很可能会出现意外情况；
2. 但纯函数不需要访问共享的内存数据，所以在并行环境下可以任意运行纯函数 (Web Worker) 

### 副作用

纯函数：对于相同的输入永远会得到相同的输出，而且没有任何可观察的副作用

```js
// 不纯的  当mini为18时，输入20为true;但是mini=21时
let mini = 18
function checkAge(age) {
    return age >= mini
}

// 纯的(有硬编码，后续可以通过柯里化解决)
function checkAge(age) {
    let mini = 18
    return age >= mini
}
```

副作用让一个函数变的不纯(如上例)，纯函数的根据相同的输入返回相同的输出，如果函数依赖于外部的状态就无法保证输出相同，就会带来副作用。

所有的外部交互都有可能带来副作用，副作用也使得方法通用性下降不适合扩展和可重用性，同时副作用会给程序中带来安全隐患给程序带来不确定性，但是副作用不可能完全禁止，尽可能控制它们在可控范围内发生。

#### 副作用的来源

配置文件、数据库、获取用户的输入

## 柯里化(Haskell Brooks Curry)

### 什么是柯里化(Currying)

当一个函数有多个参数的时候先传递一部分参数调用它（这部分参数以后永远不变），然后返回一个新的函数接收剩余的参数，返回结果。使用柯里化解决上一个案例中硬编码的问题

```js
function checkAge(age) {
    let min = 18
    return age >= min
}

// 普通纯函数
function checkAge(min, age) {
    return age >= min
}

checkAge(18, 24)
checkAge(18, 20)
checkAge(20, 30)

// 柯里化
function checkAge(min) {
    return function (age) {
        return age >= min
    }
}

// ES6 写法
let checkAge = min => (age => age >= min)
let checkAge18 = checkAge(18)
let checkAge20 = checkAge(20)
checkAge18(24)
checkAge18(20)
```

### lodash 中的柯里化函数

#### _.curry(func)

- 功能：创建一个函数，该函数接收一个或多个 func 的参数，如果 func 所需要的参数都被提供则执行 func 并返回执行的结果。否则继续返回该函数并等待接收剩余的参数。如果传了全部的参数，则执行函数，否则继续返回函数，等待剩余的参数。
- 参数：需要柯里化的函数
- 返回值：柯里化后的函数

```js
const _ = require('lodash') 
// 要柯里化的函数 
function getSum (a, b, c) { return a + b + c }
// 柯里化后的函数 
let curried = _.curry(getSum) 
// 测试 
curried(1, 2, 3) 
curried(1)(2)(3) 
curried(1, 2)(3)
```

#### 案例

```js
const _ = require('lodash')
const match = _.curry(function (reg, str) {
    return str.match(reg)
})
const haveSpace = match(/\s+/g)
const haveNumber = match(/\d+/g)
console.log(haveSpace('hello world'))
console.log(haveNumber('25$'))

const filter = _.curry(function (func, array) {
    return array.filter(func)
})
console.log(filter(haveSpace, ['John Connor', 'John_Donne']))

const findSpace = filter(haveSpace)
console.log(findSpace(['John Connor', 'John_Donne']))

// [ ' ' ]
// [ '25' ]
// [ 'John Connor' ]
// [ 'John Connor' ]
```

#### 模拟_.curry()的实现

```js
function curry(func) {
    return function curriedFn(...args) {
        // 判断实参和形参的个数 
        if (args.length < func.length) {
            return function () {
                return curriedFn(...args.concat(Array.from(arguments)))
            }
        }
        // 实参和形参个数相同，调用 func，返回结果 
        return func(...args)
    }
}

// 模拟实现 lodash 中的 curry 方法

function getSum (a, b, c) {
  return a + b + c
}

const curried = curry(getSum)

console.log(curried(1, 2, 3))
console.log(curried(1)(2, 3))
console.log(curried(1, 2)(3))
```

#### 总结

1. 柯里化可以让我们给一个函数传递较少的参数得到一个已经记住了某些固定参数的新函数
2. 这是一种对函数参数的'缓存'
3. 让函数变的更灵活，让函数的粒度更小
4. 可以把多元函数转换成一元函数，可以组合使用函数产生强大的功能

## 函数组合

纯函数和柯里化函数很容易写出洋葱代码h(g(f(x)))，如获取数组的最后一个元素再转换成大写字母， `_.toUpper(_.first(_.reverse(array)))`

函数组合可以让我们把细粒度的函数重新组合生成一个新的函数

### 管道

下面这张图表示程序中使用函数处理数据的过程，给 fn 函数输入参数 a，返回结果 b。可以想想 a 数据通过一个管道得到了 b 数据。

![组合函数管道1](https://interview-aliyun.oss-cn-beijing.aliyuncs.com/img/%E7%BB%84%E5%90%88%E5%87%BD%E6%95%B0%E7%AE%A1%E9%81%931.png)

当 fn 函数比较复杂的时候，我们可以把函数 fn 拆分成多个小函数，此时多了中间运算过程产生的 m 和 n。

下面这张图中可以想象成把 fn 这个管道拆分成了3个管道 f1, f2, f3，数据 a 通过管道 f3 得到结果 m，m再通过管道 f2 得到结果 n，n 通过管道 f1 得到最终结果 b 

![组合函数管道2](https://interview-aliyun.oss-cn-beijing.aliyuncs.com/img/%E7%BB%84%E5%90%88%E5%87%BD%E6%95%B0%E7%AE%A1%E9%81%932.png)

```js
fn = compose(f1, f2, f3)
b = fn(a)
```

### 组合函数

函数组合 (compose)：如果一个函数要经过多个函数处理才能得到最终值，这个时候可以把中间过程的函数合并成一个函数
函数就像是数据的管道，函数组合就是把这些管道连接起来，让数据穿过多个管道形成最终结果
函数组合默认是从右到左执行

```js
// 组合函数
function compose(f, g) {
    return function (x) {
        return f(g(x))
    }
}

function first(arr) {
    return arr[0]
}

function reverse(arr) {
    return arr.reverse()
}

// 从右到左运行
let last = compose(first, reverse)
console.log(last([1, 2, 3, 4]))  // 4 
```

lodash 中组合函数 flow() 或者 flowRight()，他们都可以组合多个函数
flow() 是从左到右运行
flowRight() 是从右到左运行，使用的更多一些

```js
const _ = require('lodash')
const toUpper = s => s.toUpperCase()
const reverse = arr => arr.reverse()
const first = arr => arr[0]
const f = _.flowRight(toUpper, first, reverse)
console.log(f(['one', 'two', 'three']))  // three
```

模拟实现 lodash 的 flowRight 方法

```js
// 多函数组合
function compose(...fns) {
    return function (value) {
       // 下一个函数的参数是上一个函数的返回值  给acc赋初识的只value
        return fns.reverse().reduce(function (acc, fn) {
            return fn(acc)
        }, value)
    }
}

//ES6
const compose = (...fns) => value => fns.reverse().reduce((acc, fn) => fn(acc), value)
```

函数的组合要满足**结合律** (associativity)：我们既可以把 g 和 h 组合，还可以把 f 和 g 组合，结果都是一样的

```js
// 结合律（associativity） 
let f = compose(f, g, h) 
let associative = compose(compose(f, g), h) == compose(f, compose(g, h)) 
// true
```

所以代码还可以像下面这个样子

```js
const _ = require('lodash') 
// const f = _.flowRight(_.toUpper, _.first, _.reverse) 
// const f = _.flowRight(_.flowRight(_.toUpper, _.first), _.reverse) 
const f = _.flowRight(_.toUpper, _.flowRight(_.first, _.reverse)) 
console.log(f(['one', 'two', 'three'])) 
// => THREE 
```

### 调试

如何调试组合函数

```js
const f = _.flowRight(_.toUpper, _.first, _.reverse) 
console.log(f(['one', 'two', 'three']))
```

```js
const _ = require('lodash') 
const trace = _.curry((tag, v) => { 
  console.log(tag, v) 
  return v 
})
const split = _.curry((sep, str) => _.split(str, sep)) 
const join = _.curry((sep, array) => _.join(array, sep)) 
const map = _.curry((fn, array) => _.map(array, fn)) 

// map(_.toLower) 遍历数组中的每一个，把它变为小写
const f = _.flowRight(join('-'), trace('map 之后'), map(_.toLower), trace('split 之后'), split(' ')) console.log(f('NEVER SAY DIE'))
// split 之后 [ 'NEVER', 'SAY', 'DIE' ]
// map 之后 [ 'never', 'say', 'die' ]
// never-say-die
```

lodash/fp

lodash 的 fp 模块提供了实用的对函数式编程友好的方法
提供了不可变 auto-curried iteratee-first data-last 的方法

lodash 是数据优先，函数之后

lodash/fp是函数优先，数据之后

```js
// lodash 和 lodash/fp 模块中 map 方法的区别 接收的参数不一致
const _ = require('lodash')

console.log(_.map(['23', '8', '10'], parseInt))
let array=['23', '8', '10']
// parseInt('23', 0, array)
// parseInt('8', 1, array)
// parseInt('10', 2, array)


const fp = require('lodash/fp')

console.log(fp.map(parseInt, ['23', '8', '10']))
// [ 23, NaN, 2 ]
// [ 23, 8, 10 ]
```

```js
// lodash 模块 
const _ = require('lodash') 

_.map(['a', 'b', 'c'], _.toUpper) 
// => ['A', 'B', 'C'] 
_.map(['a', 'b', 'c']) 
// => ['a', 'b', 'c'] 

_.split('Hello World', ' ') 

// lodash/fp 模块 
const fp = require('lodash/fp') 

fp.map(fp.toUpper, ['a', 'b', 'c']) 
fp.map(fp.toUpper)(['a', 'b', 'c']) 

fp.split(' ','Hello World') 
fp.split(' ')('Hello World')
```

```js
// 改造调试的代码
const fp = require('lodash/fp') 

const f = fp.flowRight(fp.join('-'), fp.map(_.toLower), fp.split(' ')) 
console.log(f('NEVER SAY DIE'))
```

### Point Free

Point Free：我们可以把数据处理的过程定义成与数据无关的合成运算，不需要用到代表数据的那个参数，只要把简单的运算步骤合成到一起，在使用这种模式之前我们需要定义一些辅助的基本运算函数。
不需要指明处理的数据
只需要合成运算过程
需要定义一些辅助的基本运算函数

```js
const f = fp.flowRight(fp.join('-'), fp.map(_.toLower), fp.split(' '))
```

案例演示

```js
// 非 Point Free 模式 
// Hello World => hello_world 
function f (word) { 
  return word.toLowerCase().replace(/\s+/g, '_'); 
}

// Point Free 
const fp = require('lodash/fp') 

const f = fp.flowRight(fp.replace(/\s+/g, '_'), fp.toLower) 
console.log(f('Hello World'))
// hello_world
```

把单词的首字母提取并转换成大写

```js
// 把一个字符串中的首字母提取并转换成大写, 使用. 作为分隔符
// world wild web ==> W. W. W
const fp = require('lodash/fp')

// const firstLetterToUpper = fp.flowRight(fp.join('. '), fp.map(fp.first), fp.map(fp.toUpper), fp.split(''))
const firstLetterToUpper = fp.flowRight(fp.join('. '), fp.map(fp.flowRight(fp.first, fp.toUpper)), fp.split(' '))

console.log(firstLetterToUpper('world wild web'))
```

## Functor(函子)

### 为什么要学函子

到目前为止已经已经学习了函数式编程的一些基础，但是我们还没有演示在函数式编程中如何把副作用控制在可控的范围内、异常处理、异步操作等。

### 什么是函子

容器：包含值和值的变形关系(这个变形关系就是函数)
函子：是一个特殊的容器，通过一个普通的对象来实现，该对象具有 map 方法，map 方法可以运行一个函数对值进行处理(变形关系)

最后返回一个新函子Functor

### Functor函子

```js
class Container {
  constructor (value) {
    this._value = value
  }

  map (fn) {
    return new Container(fn(this._value))
  }
}

let r = new Container(5)
  .map(x => x + 1)
  .map(x => x * x)

console.log(r)
// Container { _value: 36 }

// 演示 null undefined 的问题  报错
Container.of(null)
  .map(x => x.toUpperCase())
```

```js
// 一个容器，包裹一个值
class Container {
    // of 静态方法，可以省略 new 关键字创建对象
    static of(value) {
        return new Container(value)
    }

    constructor(value) {
        this._value = value
    }

// map 方法，传入变形关系，将容器里的每一个值映射到另一个容器
    map(fn) {
        return Container.of(fn(this._value))
    }
}

// 测试
Container.of(3).map(x => x + 2).map(x => x * x) 
```

#### 总结

1. 函数式编程的运算不直接操作值，而是由函子完成
2. 函子就是一个实现了 map 契约的对象
3. 我们可以把函子想象成一个盒子，这个盒子里封装了一个值
4. 想要处理盒子中的值，我们需要给盒子的 map 方法传递一个处理值的函数（纯函数），由这个函数来对值进行处理
5. 最终 map 方法返回一个包含新值的盒子（函子）

在 Functor 中如果我们传入 null 或 undefined

```js
// 值如果不小心传入了空值(副作用) 
Container.of(null) .map(x => x.toUpperCase()) 
// TypeError: Cannot read property 'toUpperCase' of null
```

### MayBe函子

我们在编程的过程中可能会遇到很多错误，需要对这些错误做相应的处理

MayBe 函子的作用就是可以对外部的空值情况做处理（控制副作用在允许的范围）

```js
class MayBe {
    static of(value) {
        return new MayBe(value)
    }

    constructor(value) {
        this._value = value
    }

    // 如果对空值变形的话直接返回 值为 null 的函子
    map(fn) {
        return this.isNothing() ? MayBe.of(null) : MayBe.of(fn(this._value))
    }

    isNothing() {
        return this._value === null || this._value === undefined
    }
}

// 传入具体值
MayBe.of('Hello World').map(x => x.toUpperCase())

// 传入 null 的情况
MayBe.of(null).map(x => x.toUpperCase())
// => MayBe { _value: null }
```

在 MayBe 函子中，我们很难确认是哪一步产生的空值问题，如下例：

```js
MayBe.of('hello world').map(x => x.toUpperCase()).map(x => null).map(x => x.split(' ')) 
// => MayBe { _value: null }
```

### Either函子

1. Either 两者中的任何一个，类似于 if...else...的处理
2. 异常会让函数变的不纯，Either 函子可以用来做异常处理

```js
class Left {
    static of(value) {
        return new Left(value)
    }
    constructor(value) {
        this._value = value
    }
    map(fn) {
        return this
    }
}

class Right {
    static of(value) {
        return new Right(value)
    }
    constructor(value) {
        this._value = value
    }
    map(fn) {
        return Right.of(fn(this._value))
    }
}
```

Either用来处理异常

```js
function parseJSON(json) { 
  try { 
    return Right.of(JSON.parse(json)); 
  } catch (e) { 
    return Left.of({ error: e.message}); 
  } 
}
let r = parseJSON('{ "name": "zs" }').map(x => x.name.toUpperCase()) 
console.log(r)
```

### IO函子

1. IO 函子中的 _value 是一个函数，这里是把函数作为值来处理
2. IO 函子可以把不纯的动作存储到 _value 中，延迟执行这个不纯的操作(惰性执行)，包装当前的操作纯
3. 把不纯的操作交给调用者来处理

```js
const fp = require('lodash/fp')

class IO {
    static of(x) {
        return new IO(function () {
            return x
        })
    }
    constructor(fn) {
        this._value = fn
    }
    map(fn) {
        // 把当前的 value 和 传入的 fn 组合成一个新的函数
        return new IO(fp.flowRight(fn, this._value))
    }
}

// 调用
let io = IO.of(process).map(p => p.execPath)
console.log(io._value())
// /usr/local/bin/node
```

### Task异步执行

异步任务的实现过于复杂，我们使用 folktale 中的 Task 来演示。folktale 一个标准的函数式编程库和 lodash、ramda 不同的是，他没有提供很多功能函数，只提供了一些函数式处理的操作，例如：compose、curry 等，一些函子 Task、Either、 MayBe 等 

```js
// folktale 中的 compose、curry
const { compose, curry } = require('folktale/core/lambda')
const { toUpper, first } = require('lodash/fp')

// 2 表明后面有2个参数  第一个参数是传入函数的参数个数
let f = curry(2, (x, y) => {
  return x + y
})

console.log(f(1, 2))  // 3
console.log(f(1)(2))  // 3


let f1 = compose(toUpper, first)
console.log(f1(['one', 'two']))  // one
```

Task 异步执行

folktale(2.3.2) 2.x 中的 Task 和 1.0 中的 Task 区别很大，1.0 中的用法更接近我们现在演示的函子

这里以 2.3.2 来演示

```js
// Task 处理异步任务
const fs = require('fs')
const { task } = require('folktale/concurrency/task')
const { split, find } = require('lodash/fp')

function readFile (filename) {
  return task(resolver => {
    fs.readFile(filename, 'utf-8', (err, data) => {
      if (err) resolver.reject(err)

      resolver.resolve(data)
    })
  })
}

readFile('package.json')
  .map(split('\n'))   // 转换为数组
  .map(find(x => x.includes('version')))
  .run()
  .listen({
    onRejected: err => {
      console.log(err)
    },
    onResolved: value => {
      console.log(value)
    }
  })
//  "version": "1.0.0",
```

### Point函子

Pointed 函子是实现了 of 静态方法的函子 of 方法是为了避免使用 new 来创建对象，更深层的含义是 of 方法用来把值放到上下文

Context（把值放到容器中，使用 map 来处理值）

```js
class Container { 
  static of (value) { 
    return new Container(value) 
  }
  …… 
}
Contanier.of(2).map(x => x + 5)
```

### Monad(单子)

在使用 IO 函子的时候，如果我们写出如下代码：

```js
// IO 函子的问题
const fs = require('fs')
const fp = require('lodash/fp')

class IO {
  static of (value) {
    return new IO(function () {
      return value
    })
  }

  constructor (fn) {
    this._value = fn
  }

  map (fn) {
    return new IO(fp.flowRight(fn, this._value))
  }
}

let readFile = function (filename) {
  return new IO(function () {
    return fs.readFileSync(filename, 'utf-8')
  })
}

// print的参数x就是readFile返回的函子
let print = function (x) {
  return new IO(function () {
    console.log(x)
    return x
  })
}

let cat = fp.flowRight(print, readFile)
// IO(IO(x))
let r = cat('package.json')._value()._value()
console.log(r)
```

Monad 函子是可以变扁的 Pointed 函子，IO(IO(x))

一个函子如果具有 join 和 of 两个方法并遵守一些定律就是一个 Monad 

```js
// IO Monad
const fs = require('fs')
const fp = require('lodash/fp')

class IO {
  static of (value) {
    return new IO(function () {
      return value
    })
  }

  constructor (fn) {
    this._value = fn
  }

  map (fn) {
    return new IO(fp.flowRight(fn, this._value))
  }

  join () {
    return this._value()
  }

  flatMap (fn) {
    return this.map(fn).join()
  }
}

let readFile = function (filename) {
  return new IO(function () {
    return fs.readFileSync(filename, 'utf-8')
  })
}

let print = function (x) {
  return new IO(function () {
    console.log(x)
    return x
  })
}

let r = readFile('package.json')
          // .map(x => x.toUpperCase())
          .map(fp.toUpper)
          .flatMap(print)
          .join()

console.log(r)
```

## 附录

[函数式编程指北](https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch1.html)

[函数式编程入门](http://www.ruanyifeng.com/blog/2017/02/fp-tutorial.html)

[Pointfree 编程风格指南](http://www.ruanyifeng.com/blog/2017/03/pointfree.html)

[图解 Monad](http://www.ruanyifeng.com/blog/2015/07/monad.html)

[Functors, Applicatives, And Monads In Pictures](https://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html) 